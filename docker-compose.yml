version: '3.8'

#multi container 

#ovde definisemo vise servisa (kontejnera), ovde ce i web socket service trebati da se doda
services:
  flask-app:
    build: .              #govori dockeru da builiduje image koristeci Dockerfle u trenutnom directory
    container_name: flask_app
    env_file:
      - ./devinfoDocker.env  # Ensure correct path # Load variables from .env file   
    ports:
      - "5000:5000"        #mapiraj port 5000 na host machini na port 5000 unutar kontejnera

    environment:
      - MYSQL_HOST=${MYSQL_HOST}
      - MYSQL_PORT=${MYSQL_PORT}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DB=${MYSQL_DB_NAME}

    depends_on:            #osigurava redosled pokretanja flask saceka redis i mysql pokrenu pre njega, ali ne i readines, Flask app treba sam da ceka MySQL i Redis da budu availible
      - redis
      - mysql_db
    volumes:
      - .:/usr/src/app   #Map local 'app' folder to container for live code updates, mapira ./app directory sa lokalne masine na /usr/src/app unutar kontjnera, dozvoljava LIVE CODE changes bez rebuilodvanja kontejnera
    working_dir: /usr/src/app      # Ensure Flask runs from this directory
    entrypoint: ["/bin/bash", "./wait-for-mysql.sh"]   # Use wait script before running Flask, za ovo mi je trebalo 3 dana, onaj depends on nista ne garantuje da ce flask sacekati...

    networks:              #dozvoljava komunikaciju izmedju kontejnera
      - frontend-network
      - backend-network


  redis:
    image: redis:alpine         #alpine ->lighweight verzija redis-a
    container_name: redis
    env_file:
      - ./devinfoDocker.env # Load variables from .env file   
    command: ["redis-server", "--requirepass", "${REDIS_PASSWORD}"] #command overeduje default command koja pokrece redis u kontenieru  
    networks:                                                       #redis-server pokrece redis servis unutar kontejnera i kaze da svaki klijent koji pokusa da se konektuje mora sifru da zna
      - backend-network                                             #bez sifre bi svaki klient sa pristupom naseg networka mogao ovo da se connectuje redis-cli -h YOUR_SERVER_IP -p 6379
    volumes:                                                        #i uzme info o tokenima korisnika ! 
      - redis-data:/data  # treba volume i za redis ipak nam cuva jwt token msm 2 nedelje ili tako nes

  
  #NASTAVI trebace za web socket isto container
  mysql_db:
    image: mysql:8.0
    container_name: mysql_db
    env_file:
      - ./devinfoDocker.env  # Load variables from .env file   
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DB_NAME}
    #ports:                            #zbog sigurnosti ovde necemo exposovati port
    #  - "3307:3306"                   #mapujemo host port 3307 na container port 3306
    volumes:
      - mysql_db-data:/var/lib/mysql_db    ## Persistent volume for MySQL data, koristi volume mysql-data da cuva podatke u var/lib/mysql tako kada restartujemo ili obrisemo mysql container dana DB ostane safe
      - ./dump.sql:/docker-entrypoint-initdb.d/dump.sql   ##odavde ucitavm iz svoje postojece baze kada se inicijalizuje kontjner, tabele i data
    networks:
      - backend-network

networks:
  backend-network:                  #koristimo takodje 2 networka zbog bezbednosti plask ce im moci pristupiti obema ali sa interneta nece moci se backedntu pristupiti
      driver: bridge                #koristi dockerov bridge network mode -> conteineri na ovom networku mogu izmedju sebe da komunciraju jedni sa drugima izolovani od host machine
  frontend-network:
      driver: bridge
volumes:
    mysql_db-data:                  # Named volume for MySQL data
    redis-data:  # Persistent Redis storage
